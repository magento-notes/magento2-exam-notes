5 - Using the Entity-Attribute-Value (EAV) Model
================================================

5.1 Demonstrate ability to use EAV model concepts
-------------------------------------------------

![Magento Exam Question](./images/icon-question.png)**Describe how EAV data storage works in Magento. Describe the EAV hierarchy structure.**

> EAV (Entity-attribute-value) is a model for storing entity attribute values ​​in a certain storage place. For storage, Magento 2 supports MySQL-compatible databases.
>
> The table of the classic EAV model has 3 columns:

1.  Entity (object to which the attribute value must be set)
2.  Attribute
3.  Value

> Whereas Magento has 5:

1.  A `backend_type` e.g. varchar, int, text etc is assigned for each attribute.
2.  Table eav_entity_type stores each custom and system EAV entity type separately (e.g. `catalog_product_entity`, `customer_address_entity`, sales_order etc). It's purpose is to name the tables where the entities are stored via the entity_table column. See [Section 5.3 EAV Attribute Features](#h.v4fzn8rafjf4) for available types.
3.  Table eav_entity holds system EAV entities - those that are available out-of-the-box
4.  Attributes with a `backend_type` as "static", are stored in the same table as entities. These attributes have global scope.
5.  Each `backend_type` of each entity type has its own table e.g. "`catalog_product_entity_int`", "`catalog_product_entity_decimal`", in which attribute values are stored. The name of this table is crafted according to the template {entity_table} _ {`backend_type`}, where entity_table is the name of the entity table and `backend_type` is the backend type of the attribute. These tables include the following columns:
    *  `value_id` (int)
    *  `attribute_id` (int)
    *  `store_id` (int)
    *  `entity_id` (int)
    *  `value` (type depends on the backend type).

![Magento Exam Question](./images/icon-question.png)**What happens when a new attribute is added to the system? (what frontend input's are available when adding a new attribute to the system).**

![Magento Section Chevron](./images/icon-chevron.png) Text Attributes

1.  A new record in eav_attribute table is made.
2.  One entry per store view is created in the eav_attribute_label table with the Label attribute.
3.  A new record in the catalog_eav_attribute table is created.

![Magento Section Chevron](./images/icon-chevron.png) Dropdown (dynamic) Attributes

For attributes with varying options, there are a few additional differences to the above, chiefly:

1.  eav_attribute.frontend_input = "select"
2.  eav_attribute.source_model = "Magento\Eav\Model\Entity\Attribute\Source\Table"
3.  eav_attribute.`backend_type` = "int"
4.  eav_attribute.default_value = eav_attribute_option.option_id by default
5.  Each option are added to table eav_attribute_option

![Magento Section Chevron](./images/icon-chevron.png) Price Attributes

Differences compared to Text Field:

1.  eav_attribute.frontend_input = "price"
2.  eav_attribute.backend_model = "Magento\Catalog\Model\Product\Attribute\Backend\Price"
3.  eav_attribute.`backend_type` = "decimal"

![Magento Section Chevron](./images/icon-chevron.png)Media Image

Differences compared to Text Field:

1.  eav_attribute.frontend_input = "media_image"

![Magento Section Chevron](./images/icon-chevron.png)Text swatch

Differences compared to Dropdown:

1.  catalog_eav_attribute.additional_data is in JSON output: {"swatch_input_type":"text","update_product_preview_image":"0″,"use_product_image_for_swatch":0}
2.  Each swatch option is added to eav_attribute_option_swatch

![Magento Exam Information](./images/icon-info.png)See Section [5.3 EAV Attribute Features](#h.v4fzn8rafjf4) for available types.

![Magento Exam Question](./images/icon-question.png)**What is the role of attribute sets and attribute groups?**

> Attribute Set's are applied to display different attributes for various products (eg. shoes and clothes). For example, if we have "shoe_size" and "clothing_size" attributes, and we need to display the first one for shoes, and the second - for clothes. An Attribute Set allows us to hide the unnecessary attributes, display the needed ones, modify the sorting and group.
>
> Groups simplify the process of filling product information by the administrator, but have no effect on product loading / storing logic.
>
> Attributes in attribute set settings:
>
> **Admin > Stores > Attributes > Attribute Sets**

![Magento Exam Question](./images/icon-question.png)**How are Attributes presented in the admin?**

> Product Attributes consist of a Name (label) and a Field (value) of which the administrator can change.
>
> The following attribute properties affect the display:

*   `frontend_model` - a class that describes the field display in the frontend section of a site. Inherited from `Magento\Eav\Model\Entity\Attribute\Frontend\AbstractFrontend` and overrides the `getValue()` method to change the displayed attribute values
*   `frontend_input` (Catalog Input Type for Store Owner) - The form element that is displayed in the admin section of the site. This can only be selected once per attribute.
*   `frontend_label` (Default Label) - the name of the attribute, displayed in the admin section of the site. It is also displayed in the site frontend, unless otherwise specified in the `eav_attribute_label` table (in the attribute settings it is changed in the "Manage Labels" tab)
*   `frontend_class` (Input Validation for Store Owner) - used to validate the attribute value in the admin section of the site. In the attribute settings, the property is called Input Validation for Store Owner. For email validation, the `frontend_class` property is set to "`validate-email`".

![Magento Exam Information](./images/icon-info.png)See Section [5.3 EAV Attribute Features](#h.v4fzn8rafjf4) for available types, models & classes.

![Magento Exam Question](./images/icon-question.png)**Which additional options do you have when saving EAV entities?**

![Magento Section Chevron](./images/icon-chevron.png)The EAV entity modification page offer the following capabilities:

> Default Attribute Values. Allows to set the value that will be inserted into the attribute field if it is not filled in. This simplifies the process of adding and modifying the entities. These are the potential default attribute values for the product:

*   Text Field - any one-line text
*   Textarea - any multi-line text
*   Date - any date
*   Yes/No - yes or no
*   Multiple Select - any number of options
*   Dropdown - one option
*   Price - no default value
*   Media Image - no default value
*   Visual Swatch - one option
*   Text Swatch - one option
*   Fixed Product Tax - no default value

![Magento Section Chevron](./images/icon-chevron.png)Scope selection.

> Scope allows to set different attribute values for different websites / stores / views. Below is a list of the possible attribute scope for the product:

*   Text Field - store view / website / global
*   Textarea - store view / website / global
*   Date - store view / website / global
*   Yes/No - store view / website / global
*   Multiple Select - store view / website / global
*   Dropdown - store view / website / global
*   Price - website / global (configured in Stores > Configuration > Catalog > Catalog > Price > Catalog Price Scope)
*   Media Image - store view / website / global
*   Visual Swatch - store view / website / global
*   Text Swatch - store view / website / global
*   Fixed Product Tax - global

![Magento Exam Information](./images/icon-info.png)I think the important thing here to remember is that all default attributes are configurable down to a store view level except Fixed Product Tax and Price (price is a per website thing).

![Magento Section Chevron](./images/icon-chevron.png) Attribute Set Selection (products only).

> Allows to regroup or hide the attributes that do not suit the current product type. See above for more info on Attribute Sets.

![Magento Section Chevron](./images/icon-chevron.png)EAV Entity Validation.

> Before saving an EAV entity at the client side, we have the following features:

*   Prohibition to save entities, if there are empty attribute fields with the is_required = 1 feature. It allows us to define what attributes of the entity are required to be filled in.
*   Validation of the attribute fields values by the algorithm, set in frontend_class. The following frontend classes are supported by default it Magento:
*   `validate-number`: Decimal Number
*   `validate-digits`: Integer Number
*   `validate-email`: Email
*   `validate-url`: URL
*   `validate-alpha`: Letters
*   `validate-alphanum`: Letters (a-z, A-Z) or Numbers (0-9)


Before saving an EAV entity at the server side, we have the following features:

*   Check attribute fields with `is_required = 1` for fullness. Magento checks the required fields on both the client and server sides.
*   Uniqueness check of the attribute fields with `is_unique = 1`.
*   Perform operations in `backend_model`:
*   Validation (validate method). Allows to realize additional server check before saving.
*   Operation before saving (`beforeSave` method).
*   Operation after saving (`afterSave` method).

![Magento Exam Information](./images/icon-info.png)Basically there is frontend and backend validation, before and after methods and a backend_model for those more complex attributes.

![Magento Section Chevron](./images/icon-chevron.png) Additional Attribute Parameters

> Module catalog has an additional catalog_eav_attribute table for attributes, where the following parameters are stored:

*   Frontend Input Renderer
*   Is Global
*   Is Visible
*   Is Searchable
*   Is Filterable
*   Is Comparable
*   Is Visible On Front
*   Is HTML Allowed On Front
*   Is Used For Price Rules
*   Is Filterable In Search
*   Is Used In Product Listing
*   Is Used For Sorting
*   Is Visible In Advanced Search
*   Is WYSIWYG Enabled
*   Is Used For Promo Rules
*   Is Required In Admin Store
*   Is Used in Grid
*   Is Visible in Grid
*   Is Filterable in Grid

> These parameters allow us to perform a more sophisticated attribute configuration.

![Magento Exam Information](./images/icon-info.png)These are all available parameters a user can select when creating attributes in the admin. Just gotta think back and remember them!

![Magento Exam Question](./images/icon-question.png)**How do you create customizations based on changes to attribute values?**

> To customize an attribute, modify the following attribute features:

*   `backend_model` - The model is used for processing and validating the attribute values. By default, `Magento\Eav\Model\Entity\Attribute\Backend\DefaultBackend` is used. More info on this in the above "EAV Entity Validation" subsection.
*   `source_model` - The model is used for providing the list of the attribute values. By default, `Magento\Eav\Model\Entity\Attribute\Source\Config` is used. You can choose to extend it to leverage the `getAllOptions()` method.
*   `attribute_model` - The model allows us to perform a more sophisticated attribute setting. By default, `Magento\Eav\Model\Entity\Attribute` is used, and a model, different from the default one, is rarely applied.
*   `frontend_model` - Frontend model is used for displaying the frontend part of the website. By default, `Magento\Eav\Model\Entity\Attribute\Frontend\DefaultFrontend` is applied, but you can extend it to leverage the `getValue()` method.

![Magento Exam Question](./images/icon-question.png)**Describe the key differences between EAV and flat table collections.**

> Magento typically stores catalog data in multiple tables, based on the Entity-Attribute-Value (EAV) model. Because product attributes are stored in many tables, SQL queries are sometimes long and complex.
>
> In contrast, a flat catalog creates new tables on the fly, where each row contains all the necessary data about a product or category. A flat catalog is updated automatically - either every minute, or according to your cron job. Flat catalog indexing can also speed up the processing of Catalog and [Cart Price Rules](#h.x0kvcqk03fp8). A catalog with as many as 500,000 SKUs can be indexed quickly as a flat catalog.
>
> Flat Catalog is configured in:
>
> **Admin > Stores > Configuration > Catalog > Catalog > Use Flat Catalog Category**
>
> **Admin > Stores > Configuration > Catalog > Catalog > Use Use Flat Catalog Product**

![Magento Exam Note Warning](images/icon-warning.png)Magento no longer recommends the use of a flat catalog as a best practice. Continued use of this feature is known to cause performance degradation and other indexing issues in Magento 2.1 and below.

![Magento Exam Question](./images/icon-question.png)**In which situations would you use EAV for a new entity?**

Using EAV for a new entity is advisable in case at least one of the following conditions is true:

*   There is a scope.
*   Admins and modules have the ability to add attributes into an entity or modify an attribute's `backend_type`.
*   Potentially, the number of columns in the Flat model can exceed the maximum column per table limit (1017 with InnoDB).
*   Potentially, the required amount of indexes, like INDEX in the Flat model, can exceed the maximum number of indexes per table (64 in InnoDB) or reach the amount when the entities' adding / modifying / deletion will be slow.

![Magento Exam Information](./images/icon-info.png)Good to remember in general!

![Magento Exam Question](./images/icon-question.png)**What are the pros and cons of EAV architecture?**

![Magento Section Chevron](./images/icon-chevron.png) Advantages

1.  The implementation of SCOPE in the Flat model stores a lot of unnecessary information. For example, if you want to redefine one attribute in another scope, then both EAV and Flat will create one line each. But in EAV, the number of columns is always fixed, while in Flat it can reach 1000. Additionally, there is a problem when the value is inherited from the parent scope. You can mark such values ​​as NULL, but then you must prevent the attributes from being NULL if they are not inherited.
2.  Quickly add a new attribute. Adding a new attribute does not change the EAV table in any way. In Flat, you need to add a new column. The ALTER TABLE operation is also slow. This is especially noticeable in large tables.*
3.  Changing `backend_type` attribute is faster. To change the attribute type in EAV, you need to move this attribute data from one table to another. For Flat, you need to perform ALTER TABLE.*
4.  EAV allows us to separate attribute values ​​from entity field values.
5.  The following InnoDB restrictions on the table restrict Flat:

    *  The table may contain no more than 1017 columns
    *  A table can contain a maximum of 64 indexes of type INDEX

> `*` As for EAV, when adding / changing an attribute type, an ALTER TABLE is performed if the attribute's backend type is static.

![Magento Section Chevron](./images/icon-chevron.png) Disadvantages

1.  Getting entity attribute values ​​in EAV is slower than in Flat *
2.  Search by attribute value in EAV is slower than in Flat *
3.  In Flat, you can create an index on several attributes to speed up the search *

* To speed up operations, some attributes can be set the `backend_type` as "static" and, if necessary, create indexes on the column with the attribute in the database, but then the visibility of the attribute will only be global. Another option is to use a flat table as an index if the data can be out of date.

5.2 Demonstrate ability to use EAV entity load and save
-------------------------------------------------------

![Magento Exam Note Warning](images/icon-warning.png)Entity Manager

> The `EntityManager` was introduced in Magento 2.1 . Since version 2.2 however, its use is not recommended by Magento anymore.
>
> Here is what the framework says about the class "`Magento\Framework\EntityManager\EntityManager`":
>
> "It is not recommended to use the EntityManager and its infrastructure for the Persistence Entities. In the next version a new "`PersistenceEntityManagerInterface`" will be created in order to cover the needs of the persistence with the API requests for the reading of the datas."
>
> Instead it is recommended to use the "`ResourceModel`" by inheriting from `Magento\Framework\Model\ResourceModel\Db\AbstractDb` or `Magento\Eav\Model\Entity\AbstractEntity` if it is an EAV model. For the collections and filters, it is recommended to use `Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`

![Magento Section Chevron](./images/icon-chevron.png)Working Via EntityManager

> If you want to work with `EntityManager` despite deprecation, you must provide information about the entity interface in `di.xml` for `MetadataPool` and for `HydratorPool`.
>
> Magento\Framework\EntityManager\OperationPool class contains operations array that call EntityManager for loading, saving, existence check and object deletion (C.R.U.D + check). The operation is performed by execute method.

![Magento Exam Information](./images/icon-info.png)Remember Entity Manager uses C.R.U.D + a check methodology.
```xml
<type name="Magento\Framework\EntityManager\MetadataPool">
   <arguments>
       <argument name="metadata" xsi:type="array">
           <item name="<MY>\<MODULE>\Api\Data\MyEntityInterface" xsi:type="array">
               <item name="entityTableName" xsi:type="string">myvendor_mymodule_myentity_entity</item>
               <item name="eavEntityType" xsi:type="string">myvendor_mymodule_myentity</item>
               <item name="identifierField" xsi:type="string">entity_id</item>
               <item name="entityContext" xsi:type="array">
                   <item name="store" xsi:type="string">Magento\Store\Model\StoreScopeProvider</item>
               </item>
           </item>
       </argument>
   </arguments>
</type>

<type name="Magento\Framework\EntityManager\HydratorPool">
   <arguments>
       <argument name="hydrators" xsi:type="array">
           <item name="<MY>\<MODULE>\Api\Data\MyEntityInterface" xsi:type="string">Magento\Framework\EntityManager\AbstractModelHydrator</item>
       </argument>
   </arguments>
</type>
```

| Action | Class | Sub-operation |
| --- | --- | --- |
| `checkIfExists` | `Magento\Framework\EntityManager\Operation\CheckIfExists` | By default, CheckIfExists operation checks for the existence of an entry in the main table with a direct SQL query. |
| `read` | `Magento\Framework\EntityManager\Operation\Read` | `ReadMain`, `ReadAttributes`, `ReadExtensions` |
| `create` | `Magento\Framework\EntityManager\Operation\Create` | `CreateMain`, `CreateAttributes`, `CreateExtensions` |
| `update` | `Magento\Framework\EntityManager\Operation\Update` | `UpdateMain`, `UpdateAttributes`, `UpdateExtensions` |
| `delete` | `Magento\Framework\EntityManager\Operation\Delete` | `DeleteExtensions`, `DeleteAttributes`, `DeleteMain` |

![Magento Exam Information](./images/icon-info.png)May not be necessary to remember since it's now deprecated. Again just remember Entity Manager uses C.R.U.D + a check methodology.

![Magento Section Chevron](./images/icon-chevron.png)Attribute Operations

> The EntityManager class relies on the OperationPool class Magento\Framework\EntityManager\OperationPool performing C.R.U.D operations on the entity itself. For instance, writing changes for an existing entity to the database (i.e. an update) is done using an operation subclass Magento\Framework\EntityManager\Operation\Update.
>
> Attribute Operations is responsible for performing C.R.U.D operations on attribute values into the new entities. Attribute Operations are located in the class Magento\Framework\EntityManager\Operation\AttributePool.
>
> This is defined in XML, and other modules can extend operations.

![Magento Exam Information](./images/icon-info.png)The general `app/etc/di.xml` gives clues on how this works: Whenever OperationPool is instantiated, a type definition tells the Object Manager to instantiate the OperationPool with a list of operations.

![Magento Section Chevron](./images/icon-chevron.png)Extensions Operations

> Extensions Operations can be used to perform additional persistent operations on objects, like creating many-to-many relations, an example of this in 2.1 is the CMS module - to link the entity to the store.
>
> Extensions Operations are located in the class `Magento\Framework\EntityManager\Operation\ExtensionPool`.

> Using overrides of Attributes Operations, EAV applies the following Handlers for operations:

*   `Magento\Eav\Model\ResourceModel\CreateHandler` - Writes attribute values into the new entities. Creates, if the attribute is absent in Snapshot and the new value is not empty or the attribute allows empty values.
*   `Magento\Eav\Model\ResourceModel\UpdateHandler` - takes a snapshot thanks to ReadSnapshot (which is based on ReadHandler). Then, UpdateHandler: Changes the value, if the attribute is modified relative to Snapshot and the new value is not empty or the attribute allows empty values. UpdateHandler Deletes, if the attribute is changed relative to Snapshot and the new value is empty and the attribute does not allow empty values.
*   `Magento\Eav\Model\ResourceModel\ReadHandler` - ReadHandler performs reading by: Getting all attribute tables for a specific entity_type For each table, subquery attribute values for each scope then perform a UNION ALL of all subqueries writing resulting values are written into the $entityData array.

![Magento Exam Question](./images/icon-question.png)**Describe the EAV load and save process and differences from the flat table load and save process.**

![Magento Exam Information](./images/icon-info.png)Debatable whether or not the following question is still relevant any more since Flat catalog / categories are now not recommended.

![Magento Section Chevron](./images/icon-chevron.png)Collections

> EAV Collections derive from `Magento\Eav\Model\Entity\Collection\AbstractCollection` whereas Flat Collections derive from `Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`

![Magento Section Chevron](./images/icon-chevron.png)Resource Models

> EAV Resource Models extend `Magento\Eav\Model\Entity\AbstractEntity` and must implement the `getEntityType()` method, whereas Flat Resource Models extend `Magento\Framework\Model\ResourceModel\Db\AbstractDb` and initialize in the Magento constructor `_construct()` method.

![Magento Section Chevron](./images/icon-chevron.png)Models

> Both EAV Models extend `Magento\Framework\Model\AbstractModel` but EAV Models must establish the ENTITY constant whereas Flat Models do not.

![Magento Section Chevron](./images/icon-chevron.png)Loading

* `addAttributeToSelect()` converts attribute into its code and calls `addFieldToSelect()`
* `addAttributeToFilter()` converts attribute into its code and calls `addFieldToFilter()`
* `addAttributeToSort()` converts attribute into its code and calls `addOrder()`

![Magento Section Chevron](./images/icon-chevron.png)Saving/Updating/Deleting

* `Magento\Eav\Model\ResourceModel\CreateHandler` - To create values in new entities.
* `Magento\Eav\Model\ResourceModel\UpdateHandler` - To modify / delete / add values into the existing entities.
* `Magento\Eav\Model\ResourceModel\ReadHandler` - To get the values.

![Magento Section Chevron](./images/icon-chevron.png)How to check for Flat Products

`Magento\Catalog\Model\ResourceModel\Product\Collection`:

```php
if ($this->isEnabledFlat()) {
  ...
} else {
  ...
}
```

![Magento Section Chevron](./images/icon-chevron.png)How to check for Flat Categories

`Magento\Catalog\Model\Category` model is initialized the following way:
```php
protected function _construct()
{
    // If Flat Index enabled then use it but only on frontend
    if ($this->flatState->isAvailable()) {
        $this->_init(Magento\Catalog\Model\ResourceModel\Category\Flat::class);
        $this->_useFlatResource = true;
    } else {
        $this->_init(Magento\Catalog\Model\ResourceModel\Category::class);
    }
}
```
![Magento Exam Question](./images/icon-question.png)**What happens when an EAV entity has too many attributes?**

> The advantage of EAV, compared to Flat, is that the Flat table in InnoDb can not contain more than 1017 columns. In EAV, the number of attributes is limited by the maximum size of InnoDb tables - which is far greater (4 billion tables).
>
> Too many tables on disk will have no impact on MySQL (unless you have a filesystem that can't rapidly open a filename from a very full directory. As far as active tables however, those being used frequently in queries there are effects from:

*   What queries you're running - although you aren't likely to be querying all tables within a single query.
*   table_open_cache & innodb_open_files limits the number of tables cached. Exceeding these cache limits will cause tables to close and open and need to be re-examined adding overhead to queries.
*   The overall query load on the system at any given point in time.

![Magento Exam Question](./images/icon-question.png)**How does the number of websites/stores affect the EAV load/save process?**

> The number of websites/stores impacts the entity loading / saving.
> In Magento, scope in EAV is realized due to the "store_id" column in the EAV attribute value tables.

*   store_id = 0, if scope global
*   store_id = X of the selected Store View, if not global

> Queries are loaded the following way:

```sql
SELECT XXX FROM <ENTITY_TABLE>_<`BACKEND_TYPE`> WHERE store_id IN (<STORE_IDS>)

```

> Where STORE_IDS are Store View identificators of the current context.
>
> The context is calculated recursively: In the STORE_IDS array, the identificator of the current scope is added. In case the current scope has Fallback scope, then an operation is repeated for Fallback.

![Magento Exam Information](./images/icon-info.png)The more Store Views are in the Website, the more entries in the database you need to create or modify, and therefore the slower the loading/saving.

![Magento Exam Information](./images/icon-info.png)It turns out that the number of websites / stores does not directly affect the upload speed, because when StoreScopeProvider is used during loading, the context contains no more than two store_id, i.e. does not depend on the number of websites / stores.

![Magento Exam Question](./images/icon-question.png)**How would you customize the load and save process for an EAV entity in the situations described here?**

![Magento Section Chevron](./images/icon-chevron.png)Overriding the operations

`di.xml`:
```xml
<type name="Magento\Framework\EntityManager\OperationPool">
   <arguments>
       <argument name="operations" xsi:type="array">
           <item name="<MY>\<MODULE>\Api\Data\MyEntityInterface" xsi:type="array">
               <item name="checkIsExists" xsi:type="string">MY_NAMESPACE\CheckIsExists</item>
               <item name="read" xsi:type="string">MY_NAMESPACE\Read</item>
               <item name="create" xsi:type="string">MY_NAMESPACE\Create</item>
               <item name="update" xsi:type="string">MY_NAMESPACE\Update</item>
               <item name="delete" xsi:type="string">MY_NAMESPACE\Delete</item>
           </item>
       </argument>
   </arguments>
</type>
```

![Magento Exam Information](./images/icon-info.png)You can partially override, for example, a single "read" operation, then the default operations will be used for the rest of the operations.

![Magento Section Chevron](./images/icon-chevron.png)Overriding the extensionActions

`di.xml`:
```xml
<type name="Magento\Framework\EntityManager\Operation\ExtensionPool">
   <arguments>
       <argument name="extensionActions" xsi:type="array">
           <item name="<MY>\<MODULE>\Api\Data\MyEntityInterface" xsi:type="array">
               <item name="read" xsi:type="array">
                   <item name="myReader" xsi:type="string">MY_NAMESPACE\ReadHandler</item>
               </item>
               <item name="create" xsi:type="array">
                   <item name="myCreator" xsi:type="string">MY_NAMESPACE\CreateHandler</item>
               </item>
               <item name="update" xsi:type="array">
                   <item name="myUpdater" xsi:type="string">MY_NAMESPACE\UpdateHandler</item>
               </item>
           </item>
       </argument>
   </arguments>
</type>
```

5.3 Demonstrate ability to manage attributes
--------------------------------------------

![Magento Exam Question](./images/icon-question.png)**Describe EAV attributes, including the frontend/source/backend structure.**

> Backend Model: Performs loading, saving, deletion and validation of the attribute. Different validations are used based on the eav_attribute.`backend_type`.
>
> Source Model (`eav_attribute`.`source_model`): Provides a list of values for the attributes, which is later used for dropdown/multiselect attributes.
>
> Frontend (`eav_attribute`.`frontend_input`): How the Model displays the attribute at the frontend side e.g. "`select`".

![Magento Exam Information](./images/icon-info.png)Similar things were mentioned in [Section 5.1](#h.7mu91scg3uyf) to help you remember.

![Magento Exam Information](./images/icon-info.png)See Section [5.3 EAV Attribute Features](#h.v4fzn8rafjf4) for available types.

![Magento Exam Question](./images/icon-question.png)**How would you add dropdown/multiselect attributes?**

![Magento Section Chevron](./images/icon-chevron.png) Install Data Scripts

> You can create attributes through the setup script (`Vendor\Module\Setup\InstallData` or `Vendor\Module\Setup\UpgradeData`).

![Magento Section Chevron](./images/icon-chevron.png) Data patches

![Magento Section Chevron](./images/icon-chevron.png)Admin

> Via the admin panel (for products only).

![Magento Section Chevron](./images/icon-chevron.png)Create new Extension Attribute

Define a new [Extension Attribute](#h.2lcvcwr56aq) in [`<module_dir>/etc/extension_attributes.xml`](https://store.fooman.co.nz/blog/an-introduction-to-extension-attributes.html&sa=D&ust=1609223264976000&usg=AOvVaw2D54qlN24sv9fdXKR-CbVq) In the `<attribute>` field the `type=""` is your Backend Model and should point to your new Interface. Being a dropdown/multiselect this will need to be an array .i.e `ExampleAttributeInterface[]` - plural Interfaces.

> Source Model (`eav_attribute`.`source_model`).
>
> Add a `backend_model`.
>
> Add a `frontend_model`.

Example:

```xml
<extension_attributes for="Magento\Catalog\Api\Data\ProductInterface">
   <attribute code="my_attribute" type="<MY>\<MODULE>\Api\Data\ExampleAttributeInterface[]" />
</extension_attributes>
```

Interface (Service Contract):

```php
<?php

namespace Vendor\MyModule\Api\Data;

interface ExampleAttributeInterface
{
   const VALUE = 'example_attribute_code';

   /**
    * Return value.
    *
    * @return string|null
    */
   public function getValue();

   /**
    * Set value.
    *
    * @param string|null $value
    * @return $this
    */
   public function setValue($value);
}
```
Concrete Class (Implementation)
```php
<?php

namespace Vendor\MyModule\Model;

class ExampleAttribute implements \Vendor\MyModule\Api\Data\ExampleAttributeInterface
{
   /**
    * {@inheritdoc}
    */
   public function getValue()
   {
       return $this->getData(self::VALUE);
   }

   /**
    * {@inheritdoc}
    */
   public function setValue($value)
   {
       return $this->setData(self::VALUE, $value);
   }
}
```

Saving & Retrieving

The use of plugins is the best approach here, in `di.xml`:
```xml
<type name="Magento\Catalog\Api\Data\ProductInterface">
   <plugin name="save_example_attribute" type="Vendor\MyModule\Plugin\Data\ProductExampleAttributeExtensions" />
</type>
```

Product Save
```php
<?php

namespace Vendor\MyModule\Plugin;

use Magento\Framework\Exception\CouldNotSaveException;

class ProductExampleAttributeExtensions
{
    public function afterSave(
        Magento\Catalog\Api\ProductRepositoryInterface $subject,
        Magento\Catalog\Api\Data\ProductInterface $resultProduct
    ) {
        $resultOrder = $this->saveExampleAttribute($resultProduct);
        return $resultProduct;
    }

    public function afterGet(
        Magento\Catalog\Api\ProductRepositoryInterface $subject,
        Magento\Catalog\Api\Data\ProductInterface $resultProduct

    ) {

        $resultProduct = $this->getExampleAttribute($resultProduct);
        return $resultProduct;
    }

    private function getExampleAttribute(Magento\Catalog\Api\Data\ProductInterface $product)
    {
        try {
            // The actual implementation of the repository is omitted
            // but it is where you would load your value from the database (or any other persistent storage)
            $exampleAttributeValue = $this->exampleRepository->get($product->getEntityId());
        } catch (NoSuchEntityException $e) {
            return $product;
        }

        $extensionAttributes = $product->getExtensionAttributes();
        $productExtension = $extensionAttributes ? $extensionAttributes : $this->productExtensionFactory->create();
        $exampleAttribute = $this->exampleAttributeFactory->create();
        $exampleAttribute->setValue($exampleAttributeValue);
        $productExtension->setExampleAttribute($exampleAttribute);
        $product->setExtensionAttributes($productExtension);

        return $product;
    }

    private function saveExampleAttribute(Magento\Sales\Api\Data\OrderInterface $product)
    {
        $extensionAttributes = $product->getExtensionAttributes();
        if (
            null !== $extensionAttributes && null !== $extensionAttributes->getExampleAttribute()
        ) {
            $exampleAttributeValue = $extensionAttributes->getExampleAttribute()->getValue();
            try {
                // The actual implementation of the repository is omitted
                // but it is where you would save to the database (or any other persistent storage)
                $this->exampleRepository->save($product->getEntityId(), $exampleAttributeValue);
            } catch (\Exception $e) {
                throw new CouldNotSaveException(
                    __('Could not add attribute to order: "%1"', $e->getMessage()),
                    $e
                );
            }
        }
        return $product;
    }
}

```
![Magento Exam Information](./images/icon-info.png)More info in [Section 4.1](#h.2lcvcwr56aq) to help you remember.

![Magento Exam Question](./images/icon-question.png)**What other possibilities do you have when adding an attribute (to a product, for example)?**

### ![Magento Section Chevron](./images/icon-chevron.png)EAV Attribute Features

> EAV attribute has several features that we can specify. Class `Magento\Eav\Model\Entity\Setup\PropertyMapper` class contains the conversion of property names in the setup script into EAV attribute property in the database.

| Feature in setup script | Feature in the database | Default value | Available Core Values |
| --- | --- | --- | --- |
| `attribute_model` | `attribute_model` | `null` | `Magento\Catalog\Model\ResourceModel\Eav\Attribute` |
| `backend` | `backend_model` | `null` | `Magento\Catalog\Model\Attribute\Backend\Customlayoutupdate`, `Magento\Catalog\Model\Attribute\Backend\Startdate`, `Magento\Catalog\Model\Category\Attribute\Backend\Image`, `Magento\Catalog\Model\Category\Attribute\Backend\Sortby`, `Magento\Catalog\Model\Product\Attribute\Backend\Boolean`, `Magento\Catalog\Model\Product\Attribute\Backend\Category`, `Magento\Catalog\Model\Product\Attribute\Backend\Price`, `Magento\Catalog\Model\Product\Attribute\Backend\Sku`, `Magento\Catalog\Model\Product\Attribute\Backend\Stock`, `Magento\Catalog\Model\Product\Attribute\Backend\Tierprice`, `Magento\Catalog\Model\Product\Attribute\Backend\Weight`, `Magento\Customer\Model\Attribute\Backend\Data\Boolean`, `Magento\Customer\Model\Customer\Attribute\Backend\Billing`, `Magento\Customer\Model\Customer\Attribute\Backend\Password`, `Magento\Customer\Model\Customer\Attribute\Backend\Shipping`, `Magento\Customer\Model\Customer\Attribute\Backend\Store`, `Magento\Customer\Model\Customer\Attribute\Backend\Website`, `Magento\Customer\Model\ResourceModel\Address\Attribute\Backend\Region`, `Magento\Eav\Model\Entity\Attribute\Backend\ArrayBackend`, `Magento\Eav\Model\Entity\Attribute\Backend\Datetime`, `Magento\Eav\Model\Entity\Attribute\Backend\DefaultBackend` |
| `type` | `backend_type` | `varchar` | `static`, `varchar`, `int`, `text`, `datetime`, `decimal` |
| `table` | `backend_table` | `null` | `null` |
| `frontend` | `frontend_model` | `null` | `Magento\Catalog\Model\Product\Attribute\Frontend\Image`, `Magento\Eav\Model\Entity\Attribute\Frontend\Datetime` |
| `input` | `frontend_input` | `text` |  `boolean`, `select`, `text`, `image`, `media_image`, `price`, `date`, `textarea`, `gallery`, `multiselect`, `hidden`, `multiline` |
| `label` | `frontend_label` | `null` | Any varchar up to 255 characters long |
| `frontend_class` | `frontend_class` | `null` | `null` |
| `source` | `source_model` | `null` | `Magento\Config\Model\Config\Source\Locale\Currency\All`, `Magento\Config\Model\Config\Source\Locale\Country`, `Magento\Config\Model\Config\Source\Locale\Timezone`, `Magento\Config\Model\Config\Source\Locale\Weekdaycodes`, `Magento\Config\Model\Config\Source\Locale\Weekdays`, `Magento\Config\Model\Config\Source\Locale\Currency`, `Magento\Config\Model\Config\Source\Email\Identity`, `Magento\Config\Model\Config\Source\Email\Method`, `Magento\Config\Model\Config\Source\Email\Template`, `Magento\Config\Model\Config\Source\Email\Smtpauth`, `Magento\Config\Model\Config\Source\Reports\Scope`, `Magento\Config\Model\Config\Source\Store`, `Magento\Config\Model\Config\Source\Dev\Dbautoup`, `Magento\Config\Model\Config\Source\Design\Robots`, `Magento\Config\Model\Config\Source\Yesnocustom`, `Magento\Config\Model\Config\Source\Web\Protocol`, `Magento\Config\Model\Config\Source\Web\Redirect`, `Magento\Config\Model\Config\Source\Website\AdminOptionHash`, `Magento\Config\Model\Config\Source\Website\OptionHash`, `Magento\Config\Model\Config\Source\Locale`, `Magento\Config\Model\Config\Source\Enabledisable`, `Magento\Config\Model\Config\Source\Yesno`, `Magento\Config\Model\Config\Source\Date\Short`, `Magento\Config\Model\Config\Source\Nooptreq`, `Magento\Config\Model\Config\Source\Image\Adapter`, `Magento\Config\Model\Config\Source\Admin\Page`, `Magento\Config\Model\Config\Source\Website` |
| `required` | `is_required` | `1` | `1` & `0` |
| `user_defined` | `is_user_defined` | `0` | `1` & `0` |
| `default` | `default_value` | `null` | `null` |
| `unique` | `is_unique` | `0` | `1` & `0` |
| `note` | `note` | `null` | `null` |
| `global` | `is_global` | `0` | `Magento\Eav\Model\Entity\Attribute\ScopedAttributeInterface::SCOPE_STORE` (0), `Magento\Eav\Model\Entity\Attribute\ScopedAttributeInterface::SCOPE_GLOBAL` (1), `Magento\Eav\Model\Entity\Attribute\ScopedAttributeInterface::SCOPE_WEBSITE` (2) |
| `sort_order` | `sort_order` | `null` | `null` |
| `group` | `group` | `General` | e.g. `General`, `Search Engine Optimization`, `Display Settings` |

![Magento Exam Information](./images/icon-info.png)You can also specify:

*   `option` – the list of values for dropdown/multiselect attributes

![Magento Exam Information](./images/icon-info.png)You can find `backend_type`, type, frontend_input and input values from your database's eav_attribute table. You can check for `backend_type` value for your type case and frontend_input for your input value for all attributes from this table.

![Magento Section Chevron](./images/icon-chevron.png)EAV Attribute Magento/Catalog Additional Features

Additionally, Magento/Catalog has the following properties according to Magento\Catalog\Model\ResourceModel\Setup\PropertyMapper:

| Feature in setup script | Feature in the database | Default value |
| --- | --- | --- |
| `input_renderer` | `frontend_input_renderer` | `null` |
| `visible` | `is_visible` | `1` |
| `searchable` | `is_searchable` | `0` |
| `filterable` | `is_filterable` | `0` |
| `comparable` | `is_comparable` | `0` |
| `visible_on_front` | `is_visible_on_front` | `0` |
| `wysiwyg_enabled` | `is_wysiwyg_enabled` | `0` |
| `is_html_allowed_on_front` | `is_html_allowed_on_front` | `0` |
| `visible_in_advanced_search` | `is_visible_in_advanced_search` | `0` |
| `filterable_in_search` | `is_filterable_in_search` | `0` |
| `used_in_product_listing` | `used_in_product_listing` | `0` |
| `used_for_sort_by` | `used_for_sort_by` | `0` |
| `apply_to` | `apply_to` | `null` |
| `position` | `position` | `0` |
| `used_for_promo_rules` | `is_used_for_promo_rules` | `0` |
| `is_used_in_grid` | `is_used_in_grid` | `0` |
| `is_visible_in_grid` | `is_visible_in_grid` | `0` |
| `is_filterable_in_grid` | `is_filterable_in_grid` | `0` |
| `attribute_set` | `attribute_set` | `null` (Accepts strings such as "Default") |

![Magento Exam Question](./images/icon-question.png)**Describe how to implement the interface for attribute frontend models. What is the purpose of this interface? How can you render your attribute value on the frontend?**

![Magento Section Chevron](./images/icon-chevron.png)How

> To create Frontend model, create a class, inherited from `Magento\Eav\Model\Entity\Attribute\Frontend\AbstractFrontend`, and override getValue method.Then, set frontend_model as the name of the newly created class.
```PHP
class TestFrontend extends \Magento\Eav\Model\Entity\Attribute\Frontend\AbstractFrontend
{
    public function getValue(Magento\Framework\DataObject $object)
    {
        $attribute_code = $this->getAttribute()->getAttributeCode();
        $value = $object->getData($attribute_code);
        return nl2br(htmlspecialchars($value));
    }
}
```

![Magento Section Chevron](./images/icon-chevron.png)Why (purpose).

> The purpose of the interface is to decrease the code dependency (dependency inversion principle).

![Magento Exam Question](./images/icon-question.png)**Identify the purpose and describe how to implement the interface for attribute source models.**

> The model is used for providing a list of attribute values for dropdown/multiselect attributes. Source model realization example:

```PHP
class TestSource extends \Magento\Eav\Model\Entity\Attribute\Source\AbstractSource
{
    public function getAllOptions()
    {
        if (!$this->_options) {
            $this->_options = [
                ['label' => __('Label 1'), 'value' => 'value 1'],
                ['label' => __('Label 2'), 'value' => 'value 2'],
                ['label' => __('Label 3'), 'value' => 'value 3'],
                ['label' => __('Label 4'), 'value' => 'value 4']
            ];
        }

        return $this->_options;
    }
}
```
![Magento Exam Question](./images/icon-question.png)**For a given dropdown/multiselect attribute, how can you specify and manipulate its list of options?**

> The values are stored in the eav_attribute_option_value table. If the source_model is the `Magento\Eav\Model\Entity\Attribute\Source\Table` class or is inherited from it. The values can be added when creating an attribute in the option property, or you can call the `Magento\Eav\Setup\EavSetup->addAttributeOption($option)` method.
>
> If the source model is not inherited from `Magento\Eav\Model\Entity\Attribute\Source\Table`, then, to change the list of values, you can:

*   Create a plugin on the source model on the `getAllOptions` method
*   Create a new source model, inherited from the mutable class, change the behavior of the `getAllOptions` method and specify the new `source_model` in the attributes

![Magento Exam Information](./images/icon-info.png)Just remember that The values are stored in the eav_attribute_option_value table and that the `source_model` column should reference a class inherited from `Magento\Eav\Model\Entity\Attribute\Source\Table` which allows you to override the `addAttributeOption` method.

![Magento Exam Question](./images/icon-question.png)**Identify the purpose and describe how to implement the interface for attribute backend models.**

> Backend modules are created with a purpose to upload / save / delete / validate attribute values.

![Magento Section Chevron](./images/icon-chevron.png)How

`<module_dir>etc\adminhtml\system.xml`
```xml
<field id="config_example" translate="label" type="obscure" sortOrder="40" showInDefault="1" showInWebsite="1">
    <label>API Password</label>
    <config_path>my_module/section/config_example</config_path>
    <backend_model>Vendor\MyModule\Model\Config\Backend\TestBackend</backend_model>
    <attribute type="shared">1</attribute>
</field>
```

```php
class TestBackend implements Magento\Framework\App\Config\ValueInterface
{
    public function isValueChanged($object)
    {
    }

    Public function getOldValue()
    {
    }

    public function getFieldsetDataValue($key)
    {
    }
}
```

![Magento Section Chevron](./images/icon-chevron.png)How (and why) would you create a backend model for an attribute?

> Backend modules are created with a purpose to upload / save / delete / validate attribute values.

![Magento Exam Question](./images/icon-question.png)**Describe how to create and customize attributes. How would you add a new attribute to the product, category, or customer entities? What is the difference between adding a new attribute and modifying an existing one?**

![Magento Section Chevron](./images/icon-chevron.png)Adding a new attribute

Data patches are used for creating a new attribute using the injected method:

```php
Magento\Eav\Setup\EavSetupFactory->create()->addAttribute(string $entityType, string $attributeCode, array $properties)
```

*   For Products use entity code `Magento\Catalog\Model\Product::ENTITY`
*   For Inventory use entity code `Magento\CatalogInventory\Model\Stock::ENTITY`
*   For Stock Items use entity code `Magento\CatalogInventory\Model\Stock\Item::ENTITY`
*   For Categories use entity code `Magento\Catalog\Model\Category::ENTITY`
*   For Customers use entity code `Magento\Customer\Model\Customer::ENTITY`
*   For Customer Groups use entity code `Magento\Customer\ModelGroup::ENTITY`
*   For Customer Address use entity code `Magento\Customer\Model\Indexer\Address\AttributeProvider::ENTITY`

[More info on Data Patches in Section 4.2](#h.8i0etxv2dw9i)

![Magento Exam Information](./images/icon-info.png)For products you can also [manually create attributes via the admin](https://docs.magento.com/user-guide/stores/attributes-product.html&sa=D&ust=1609223265035000&usg=AOvVaw0p75AzVbovNy8DnDVQaMh8) in Stores > Attributes > Product

![Magento Exam Information](./images/icon-info.png)For customers you can also [manually create attributes via the admin](https://docs.magento.com/user-guide/stores/attributes-customer.html&sa=D&ust=1609223265035000&usg=AOvVaw31283qtMpVdnNfLYT466ui) in Stores > Attributes > Customer (Magento Enterprise Commerce feature only).

![Magento Exam Note Warning](images/icon-warning.png)Setup scripts are applied to create or modify an attributes, however this has become deprecated as of Magento 2.3

![Magento Section Chevron](./images/icon-chevron.png)Modifying an existing attribute

> Much like creating an attribute (above), use a Data Patch with the same injected class:

```php
Magento\Eav\Setup\EavSetupFactory->create()->updateAttribute(string $entityType, string $attributeCode, string $attributeField, mixed $value = null, int $sortOrder = null);
```
[More info on Data Patches in Section 4.2](#h.8i0etxv2dw9i)

![Magento Exam Information](./images/icon-info.png)For customers you can also [manually modify most attributes via the admin](https://docs.magento.com/user-guide/stores/attributes-customer.html&sa=D&ust=1609223265037000&usg=AOvVaw3nuq9nltxOteADYAxh-H1F) in Stores > Attributes > Customer (Magento Enterprise Commerce feature only). However, properties such as: frontend_class & attribute_code ARE NOT editable after creation.

![Magento Exam Information](./images/icon-info.png)For products you can [manually modfiy most attributes via the admin](https://docs.magento.com/user-guide/stores/attributes-product.html&sa=D&ust=1609223265037000&usg=AOvVaw2yFkHEc2Lva4xKVBXLJ5xL) in Stores > Attributes > Product. However, properties such as: input_type, attribute_code, sort_order, used_in_forms ARE NOT editable after creation.

![Magento Exam Note Warning](images/icon-warning.png)Setup scripts are applied to create or modify an attributes, however this has become deprecated as of Magento 2.3